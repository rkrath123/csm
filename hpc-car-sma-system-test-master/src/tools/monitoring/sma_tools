#!/bin/bash

SMA_TOOLS=true
SMA_TOOLS_VERSION="1.1.0"
SMA_TOOLS_HOME=/tmp/sma-sos
PATH=$PATH:${SMA_TOOLS_HOME}

SMA_SERVER=`hostname -f`
SMA_NAMESPACE=sma
SMA_API_GATEWAY="api-gw-service-nmn.local"
SMA_COMPUTE_NODES=( "nid000001-nmn" "nid000002-nmn" "nid000003-nmn" "nid000004-nmn" )

SMA_INIT_PODS=( "mysql-init" "sma-db-init" "sma-init" "postgres-persister-init" "grafana-init" )
SMA_INIT_PODS+=("sma-ldms-config" "sma-monasca-alarms-init-job" "sma-monasca-kafka-init-job" "sma-monasca-mysql-init-job" "sma-monasca-cleanup-job")
SMA_SKIP_PODS=( "hms-hmcollector" "hms-pmdbd" "hms-postgresql-util" "hms-postgresql-pruner" "sma-ldms-map-pvc" "grafana-init" "cstream-setup" )
SMA_SKIP_PODS+=( "elasticsearch-test" "grafana-test" "kafka-test" "kibana-test" "pod-status-test" "postgres-test" "rsyslog-test" "telemetry-test" )
SMA_SKIP_PODS+=( "sma-cstream" )
SMA_SERVICES_PODS=( "sma-telemetry-api" "grafana" "kibana" "grafana-init" )

# define array of health checks used by sma_status command
SMA_HEALTH_CHECKS=(
 "${SMA_TOOLS_HOME}/sma_kafka_health.sh" 
 "${SMA_TOOLS_HOME}/sma_postgres_health.sh"
 "${SMA_TOOLS_HOME}/sma_telemetry_api_health.sh"
 "${SMA_TOOLS_HOME}/sma_log_health.sh"
 "${SMA_TOOLS_HOME}/sma_svc_health.sh"
 "${SMA_TOOLS_HOME}/sma_ui_health.sh"
)

alias k="kubectl"
alias sma_status="${SMA_TOOLS_HOME}/sma_status.sh"
alias sma_healthcheck="${SMA_TOOLS_HOME}/sma_healthcheck.sh"
alias sma_kafka_health="${SMA_TOOLS_HOME}/sma_kafka_health.sh"
alias sma_postgres_health="${SMA_TOOLS_HOME}/sma_postgres_health.sh"
alias sma_log_health="${SMA_TOOLS_HOME}/sma_log_health.sh"
alias sma_pvc_health="${SMA_TOOLS_HOME}/sma_pvc_health.sh"
alias sma_svc_health="${SMA_TOOLS_HOME}/sma_svc_health.sh"
alias sma_telemetry_api_health="${SMA_TOOLS_HOME}/sma_telemetry_api_health.sh"
alias sma_cgroup_stats="${SMA_TOOLS_HOME}/sma_cgroup_stats.sh"

complete -F __start_kubectl k

function runit () {
        echo $@
        eval $@
}

function echoerr() {
	# if stdout is not terminal
	if [ ! -t 1 ]; then
		echo $*
	fi
	printf "%s\n" "$*" >&2;
}

show_version () {
	runit date
	echo ${SMA_SERVER}
	runit uptime
	echo
	cat /etc/cray-release
	echo
	cmd="docker images"
	runit $cmd
	echo
}

show_build () {
	cat /etc/cray-release
}

function get_system_name {
	name=$(cat /opt/cray/system_name)
	if [ $? -ne 0 ]; then
		name="system name was not found"
	fi
	echo $name
}

# Get the shasta system's domain name
function get_shasta_domain {
	name=$(cat /etc/ansible/hosts/group_vars/all/kubernetes.yml | grep shasta_domain: | awk '{ print $2 }')
	if [ $? -ne 0 ]; then
		name="domain name was not found"
	fi
	echo $name
}

# Get number of ncn nodes in a shasta system.
function get_num_ncns {
	num_ncns=$(kubectl get nodes --no-headers -o custom-columns=NAME:.metadata.name | wc -l)
	echo $num_ncns
}

# Get number of configured compute nodes in a shasta system.
function get_num_computes {
	num_computes=$(cray hsm State Components list --role=Compute --state=Ready --format=json | grep Compute | wc -l)
	echo $num_computes
}

# Get number of configured switches in a shasta system.
function get_num_switches {
	num_switches=0
	cray hsm Inventory RedfishEndpoints list >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		num_switches=$(cray hsm Inventory RedfishEndpoints list | wc -l)
	fi
	echo $num_switches
}

# Shasta configuration
function show_shasta_config {
	num_computes=$(get_num_computes)
	num_switches=$(get_num_switches)
	num_ncns=$(get_num_ncns)
	system=$(get_system_name)

	echo "Collected on ${system} at `date` (`date -u`)"
	show_build
	echo "uptime=`uptime`"
	echo "shasta ncn count= ${num_ncns}"
	echo "shasta compute count= ${num_computes}"
	echo "shasta switch count= ${num_switches}"
}

# Returns 0 if ldms looks to be configured and running on selected computes.
function is_ldms_on_computes {
	errs=0
	for node in "${SMA_COMPUTE_NODES[@]}"; do
		ssh -o "StrictHostKeyChecking=no" $node "systemctl status ldmsd@compute" >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "compute node $node failed"
			errs=$((errs+1))
		fi
	done
	return $errs
}

# Returns 0 if log forwarding looks to be configured on select computes.
function is_rsyslog_on_computes {
	errs=0
	for node in "${SMA_COMPUTE_NODES[@]}"; do
		ssh -o "StrictHostKeyChecking=no" $node "[ -f "/etc/rsyslog.d/*cray-rsyslog.conf" ] && exit 0 || echo 1" >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "compute node $node failed"
			errs=$((errs+1))
		fi
	done
	return $errs
}

# Return a healthy kafka service.
function get_kafka_pod {

	pods=$(kubectl -n sma get pods | grep cluster-kafka | awk '{ print $1 }')
	for pod in ${pods}
	do
		kubectl -n sma exec ${pod} -c kafka -- /opt/kafka/bin/kafka-broker-api-versions.sh --bootstrap-server localhost:9092 >/dev/null 2>/dev/null
		if [ $? -eq 0 ]; then
			# looks healthy
			echo ${pod}
			return
		fi
	done
	echo "cluster-kafka-0"
}

# Returns postgres leader.
function get_postgres_leader {
	leader=$(kubectl -n sma get pod -l application=spilo -L spilo-role -o wide | grep master | awk '{ print $1 }')
	echo ${leader}
}

function get_pod_uid {
	uid=$(kubectl -n ${SMA_NAMESPACE} get pods | grep $1 |  awk '{ print $1 }')
	if [ $? -ne 0 ] ; then
		unset uid
	fi
	echo $uid
}

function sma_help() {
	echo "env - show SMA docker environment variables"
	echo "version - SMA release version information" 
	echo "build - SMA build information" 
	echo "machinename - SMA machine name"
	echo "get_auth_token - Get an access token for API authentication"
	echo "ps - list of SMA services"
	echo "status - check status of SMA services"
	echo "stats - get SMA service resource statistics (memory, cpu) usage"
	echo "sh SERVICE - execute bash shell in the SMA container"
	echo "logs SERVICE - view logs for the SMA service"
	echo "stop [SERVICE | all] - stop SMA service(s)"
	echo "start [SERVICE | all] - start SMA service(s)"
	echo "restart [SERVICE | all] - restart SMA service(s)"
	echo "cstream_config - get SMA cstream configuration map"
	echo "healthcheck - check if SMA looks healthy"
#	echo "alarmcheck - check state of SMA alarms"
	echo "sosreport - collect report for troubleshooting SMA"
}

function sma_env() {
	echo SMA_TOOLS_HOME=$SMA_TOOLS_HOME
	echo SMA_SERVER=$SMA_SERVER
	echo SMA_NAMESPACE=$SMA_NAMESPACE
	echo SMA_API_GATEWAY=$SMA_API_GATEWAY
}

function sma_machinename {
	show_machinename
}

function sma_version() {
	show_version
}

function sma_build() {
	show_build
}

# Get an access token as a credential to call a target API. The passed token informs the API that the bearer of the token has 
# been authorized to access the API and perform specific actions that was granted during authorization.
# FIXME? /opt/cray/tests/ncn-resources/bin/get_api_token
function sma_get_auth_token {
	cert="/usr/share/pki/trust/anchors/certificate_authority.crt"
	if [ ! -f ${cert} ]; then
		# returns an invalid token
		echo "Error: ca cert file not found ${cert}"
	fi
	secret=$(kubectl get secrets admin-client-auth -ojsonpath='{.data.client-secret}' | base64 -d)
	token=$(curl -s --cacert ${cert} -d grant_type=client_credentials -d client_id=admin-client -d client_secret=${secret} https://${SMA_API_GATEWAY}/keycloak/realms/shasta/protocol/openid-connect/token)
	access_token=$(echo ${token} | jq -r .access_token)
	if [ -z "${access_token}" ]; then
		echo "Error: access token not created"
	else
		echo ${access_token}
	fi
}

function sma_sh() {
	uid=$(get_pod_uid $1)
	if [ -z "$uid" ] ; then
		uid=$1
	fi
	if [ ! -z "$2" ] ; then
		cmd="kubectl -n ${SMA_NAMESPACE} exec $uid -c $2 -it -- bash -l"
	else
		cmd="kubectl -n ${SMA_NAMESPACE} exec $uid -it -- bash -l"
	fi
	runit $cmd
}

function sma_follow_logs() {
 	cmd="kubectl -n ${SMA_NAMESPACE} logs --timestamps --follow=true $1"
	runit $cmd
}

function sma_logs() {
	tail_lines=1000
	echo "$1"
	echo ------------------------------------
	DATE=`kubectl -n ${SMA_NAMESPACE} exec -i $1 -- sh -c date`
	echo $DATE; echo
# 	cmd="kubectl -n ${SMA_NAMESPACE} logs --timestamps --tail $tail_lines $1"
	if [[ $# -gt 1 ]] ; then
		cmd="kubectl -n ${SMA_NAMESPACE} logs --timestamps $1 -c $2"
	else
		cmd="kubectl -n ${SMA_NAMESPACE} logs --timestamps $1"
	fi
	runit $cmd
	echo ------------------------------------
}

function sma_stats() {
	cmd="docker stats --no-stream --format \"table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\" | sort -k 1"
	runit $cmd
}

function sma_ps() {
	cmd="docker ps -f name=sma_ --format \"table {{.Names}}\t{{.CreatedAt}}\t{{.Status}}\" | sort -k 1"
	runit $cmd
}

function sma_start() {
	ls -l /root/k8s/sma-*
	if [[ $# -gt 1 ]] ; then
		ls -l /root/k8s/$1
		if [ $? -ne 0 ]; then
			echo "K8s config '$1' not found"
			return
		fi
#		kubectl apply -f /root/k8s/$1.yaml
		if [ $? -ne 0 ]; then
			echo "apply failed"
			exit 1
		fi
	fi
	exit 0
}

function sma_stop() {
	ls -l /root/k8s/sma-*
	if [[ $# -gt 1 ]] ; then
		ls -l /root/k8s/$1
		if [ $? -ne 0 ]; then
			echo "K8s config '$1' not found"
			return
		fi
#		kubectl delete -f /root/k8s/$1.yaml
		if [ $? -ne 0 ]; then
			echo "delete failed"
			exit 1
		fi
	fi
	exit 0
}

function sma_restart() {
	uid=$(get_pod_uid $1)
	if [ -z "$uid" ] ; then
		echo "App '$app' not found"
		return
	fi
	cmd="kubectl -n ${SMA_NAMESPACE} delete pod $uid"
	runit $cmd
}

function sma_cstream_config() {
	kubectl -n sma get configmap cstream-config -o yaml
}

function sma() {
	action=$1
	shift
	funcname="sma_"${action}
	eval ${funcname} "$@"
}

# vim:shiftwidth=4:softtabstop=4:tabstop=4:
